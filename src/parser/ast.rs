use std::collections::HashMap;

use crate::{
    interpreter::value::Value,
    lexer::{lexer::InputSource, op::Operator},
    type_checker::types::{CheckedType, FunctionParameterType, GetType, Type},
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RecordKeyAst {
    String(String),
    Integer(String),
    Float(String),
    Char(char),
}

/// Module is the root program node of the AST
/// It contains a list of all the expressions in the program
pub struct Module {
    pub expressions: Vec<Ast>,
    pub source: InputSource,
}

impl Module {
    pub fn new(expressions: Vec<Ast>, source: InputSource) -> Module {
        Module {
            expressions,
            source,
        }
    }
}

/**
 * The AST is a tree of nodes that represent the program.
 * All nodes are expressions, and the root node is the program itself.
 * The AST is generated by the parser, and then interpreted by the interpreter module or compiled.
 */
#[derive(Debug, Clone, PartialEq)]
pub enum Ast {
    /// Primitive values such as Integer, Float, String, Char and Boolean (NOT compound data structures)
    Literal(Value),
    /// A tuple is a fixed-size collection of elements of possibly different types.
    Tuple(Vec<Ast>, CheckedType),
    /// A dynamic list of elements of the same type.
    List(Vec<Ast>, CheckedType),
    Record(HashMap<RecordKeyAst, Ast>, CheckedType),
    Identifier(String, CheckedType),
    TypeIdentifier(String, CheckedType),
    FunctionCall(String, Vec<Ast>, CheckedType),
    Function(String, FunctionParameterType, Box<Ast>, CheckedType),
    Binary(Box<Ast>, Operator, Box<Ast>, CheckedType),
    Unary(Operator, Box<Ast>, CheckedType),
    Assignment(Box<Ast>, Box<Ast>, CheckedType),
    /// Block expression evaluates all expressions in the block and returns the value of the last expression.
    Block(Vec<Ast>, CheckedType),
}

impl GetType for Ast {
    fn get_type(&self) -> CheckedType {
        CheckedType::Checked(match self {
            Ast::Literal(value) => return value.get_type(),
            Ast::Tuple(_, CheckedType::Checked(t)) => t.clone(),
            Ast::List(_, CheckedType::Checked(t)) => t.clone(),
            Ast::Record(_, CheckedType::Checked(t)) => t.clone(),
            Ast::Identifier(_, CheckedType::Checked(t)) => t.clone(),
            Ast::TypeIdentifier(_, CheckedType::Checked(t)) => t.clone(),
            Ast::FunctionCall(_, _, CheckedType::Checked(t)) => t.clone(),
            Ast::Function(_, _, _, CheckedType::Checked(t)) => t.clone(),
            Ast::Binary(_, _, _, CheckedType::Checked(t)) => t.clone(),
            Ast::Unary(_, _, CheckedType::Checked(t)) => t.clone(),
            Ast::Assignment(_, _, CheckedType::Checked(t)) => t.clone(),
            Ast::Block(_, CheckedType::Checked(t)) => t.clone(),
            _ => return CheckedType::Unchecked,
        })
    }
}

pub fn tuple(elements: Vec<Ast>) -> Ast {
    Ast::Tuple(elements, CheckedType::Unchecked)
}

/**
 * Create a new unit AST node.
 * Implemented as a tuple with no elements.
 */
pub fn unit() -> Ast {
    Ast::Tuple(vec![], CheckedType::Checked(Type::Unit))
}
